{#- PCILeech Top-Level Wrapper Template -#}
{{ header | safe }}

`default_nettype none
{% from "_helpers.j2" import safe_int, get_vendor_id, get_device_id %}
{#- Determine lane count from context - defaults to X1 if not specified -#}
{% set _max_lanes = max_lanes | default(1) %}
{% set _lane_width = (_max_lanes - 1) %}

module pcileech_top (
    // PCIe physical transceiver interface
    output wire [{{ _lane_width }}:0]  pci_exp_txp,
    output wire [{{ _lane_width }}:0]  pci_exp_txn,
    input  wire [{{ _lane_width }}:0]  pci_exp_rxp,
    input  wire [{{ _lane_width }}:0]  pci_exp_rxn,

    // System clock and reset (external)
    input  wire        sys_clk_p,
    input  wire        sys_clk_n,
    input  wire        sys_rst_n
{%- set _enable_pme = enable_pme|default(false) %}
{%- set _enable_wake_events = enable_wake_events|default(false) %}
{#- Expose sideband pins only when explicitly requested by context -#}
{%- set _expose_pm_sideband = expose_pm_sideband|default(power_management.has_interface_signals if power_management is defined else false) %}
{#- Only add the leading comma if at least one optional port will be emitted -#}
{%- set _has_optional_ports = _expose_pm_sideband and (_enable_pme or _enable_wake_events) %}
{%- if _has_optional_ports %}
    ,
    // Optional PCIe power management sideband (expose for integration)
{%- if _enable_pme %}
    input  wire         pme_turnoff,
    input  wire         aux_pwr_present,
    output logic        pme_to_ack{%- if _enable_wake_events %},{% endif %}
{%- endif %}
{%- if _enable_wake_events %}
    output logic        wake_n
{%- endif %}
{%- endif %}
);

    // Internal PCIe interface signals
    {#- 7-series PCIe core exposes 64-bit AXI-Stream even for x1 in common configs -#}
    {%- set _data_width = 64 %}
    logic        clk;
    logic        reset_n;
    logic        device_ready;
    logic [{{ _data_width - 1 }}:0] pcie_rx_data;
    logic        pcie_rx_valid;
    logic [{{ _data_width - 1 }}:0] pcie_tx_data;
    logic        pcie_tx_valid;
    logic        pcie_tx_ready;

    // Additional AXI-Stream sideband/control signals required by core
    logic  [({{ _data_width }} / 8) - 1:0] s_axis_tx_tkeep;
    logic        s_axis_tx_tlast;
    logic  [3:0] s_axis_tx_tuser;
    logic  [({{ _data_width }} / 8) - 1:0] m_axis_rx_tkeep;
    logic        m_axis_rx_tlast;
    logic [21:0] m_axis_rx_tuser;
    logic        m_axis_rx_tready;
    
    // Configuration space management interface (7-series uses cfg_mgmt_*, not cfg_ext_*)
    logic [31:0] cfg_mgmt_do;
    logic        cfg_mgmt_rd_wr_done;
    logic [31:0] cfg_mgmt_di;
    logic  [3:0] cfg_mgmt_byte_en;
    logic  [9:0] cfg_mgmt_dwaddr;
    logic        cfg_mgmt_wr_en;
    logic        cfg_mgmt_rd_en;
    logic        cfg_mgmt_wr_readonly;
    
    // Interrupt status (outputs) and INTx/MSI inputs (tied off if MSI-X only)
    logic        cfg_interrupt_msixenable;
    logic        cfg_interrupt_msixfm;
    logic        cfg_interrupt_rdy;
    logic  [7:0] cfg_interrupt_do;
    logic  [2:0] cfg_interrupt_mmenable;
    logic        cfg_interrupt_msienable;

    // Tie-off inputs for legacy/MSI interrupt path (INTx/MSI)
    logic        cfg_interrupt;                 // tie low
    logic        cfg_interrupt_assert;          // tie low
    logic  [7:0] cfg_interrupt_di;             // tie 0
    logic        cfg_interrupt_stat;            // tie low
    logic  [4:0] cfg_pciecap_interrupt_msgnum;  // tie 0

    // Flow control and throttling
    logic  [2:0] fc_sel;                        // tie 0 when unused

    // Non-posted request controls
    logic        rx_np_ok;                      // tie 1 when always ok
    logic        rx_np_req;                     // tie 1 when always request allowed

    // TX config grant (some variants require a grant)
    logic        tx_cfg_gnt;                    // tie 1 when no arbiter present
    
    // Debug status (internal)
    logic [31:0] debug_status;

    // PCIe IP Core instantiation (7-Series)
    pcie_7x_bridge pcie_core (
        .pci_exp_txp(pci_exp_txp),
        .pci_exp_txn(pci_exp_txn),
        .pci_exp_rxp(pci_exp_rxp),
        .pci_exp_rxn(pci_exp_rxn),
        
        .user_clk_out(clk),
        .user_reset_out(reset_n),
        .user_lnk_up(device_ready),
        .user_app_rdy(),
        
        // AXI-Stream interface to BAR controller
        .m_axis_rx_tdata(pcie_rx_data),
        .m_axis_rx_tkeep(m_axis_rx_tkeep),
        .m_axis_rx_tlast(m_axis_rx_tlast),
        .m_axis_rx_tvalid(pcie_rx_valid),
        .m_axis_rx_tready(m_axis_rx_tready),
        .m_axis_rx_tuser(m_axis_rx_tuser),

        .s_axis_tx_tdata(pcie_tx_data),
        .s_axis_tx_tkeep(s_axis_tx_tkeep),
        .s_axis_tx_tlast(s_axis_tx_tlast),
        .s_axis_tx_tvalid(pcie_tx_valid),
        .s_axis_tx_tuser(s_axis_tx_tuser),
        .s_axis_tx_tready(pcie_tx_ready),
        
        // Configuration management interface (7-series)
        .cfg_mgmt_do(cfg_mgmt_do),
        .cfg_mgmt_rd_wr_done(cfg_mgmt_rd_wr_done),
        .cfg_mgmt_di(cfg_mgmt_di),
        .cfg_mgmt_byte_en(cfg_mgmt_byte_en),
        .cfg_mgmt_dwaddr(cfg_mgmt_dwaddr),
        .cfg_mgmt_wr_en(cfg_mgmt_wr_en),
        .cfg_mgmt_rd_en(cfg_mgmt_rd_en),
        .cfg_mgmt_wr_readonly(cfg_mgmt_wr_readonly),
        
        // MSI/MSI-X and INTx
        .cfg_interrupt(cfg_interrupt),
        .cfg_interrupt_rdy(cfg_interrupt_rdy),
        .cfg_interrupt_assert(cfg_interrupt_assert),
        .cfg_interrupt_di(cfg_interrupt_di),
        .cfg_interrupt_do(cfg_interrupt_do),
        .cfg_interrupt_mmenable(cfg_interrupt_mmenable),
        .cfg_interrupt_msienable(cfg_interrupt_msienable),
        .cfg_interrupt_msixenable(cfg_interrupt_msixenable),
        .cfg_interrupt_msixfm(cfg_interrupt_msixfm),
        .cfg_interrupt_stat(cfg_interrupt_stat),
        .cfg_pciecap_interrupt_msgnum(cfg_pciecap_interrupt_msgnum),

        // Flow control selections
        .fc_sel(fc_sel),

        // Non-posted request controls
        .rx_np_ok(rx_np_ok),
        .rx_np_req(rx_np_req),

        // TX config grant (tie high if unused)
        .tx_cfg_gnt(tx_cfg_gnt),
        
        .sys_clk(sys_clk_p),
        .sys_rst_n(sys_rst_n)
    );

    // BAR controller signals  
    logic [31:0] bar_addr;
    logic [31:0] bar_wr_data;
    logic        bar_wr_en;
    logic        bar_rd_en;
    logic [31:0] bar_rd_data;

    // Configuration management defaults (tie off for basic operation)
    assign cfg_mgmt_di = 32'h0;
    assign cfg_mgmt_byte_en = 4'h0;
    assign cfg_mgmt_dwaddr = 10'h0;
    assign cfg_mgmt_wr_en = 1'b0;
    assign cfg_mgmt_rd_en = 1'b0;
    assign cfg_mgmt_wr_readonly = 1'b0;

    // AXI-Stream and basic control tie-offs to keep core happy in minimal mode
    assign s_axis_tx_tkeep = {({{ _data_width }} / 8){1'b1}};
    assign s_axis_tx_tlast = 1'b1;
    assign s_axis_tx_tuser = 4'h0;
    assign m_axis_rx_tready = 1'b1;
    assign rx_np_ok = 1'b1;
    assign rx_np_req = 1'b1;
    assign fc_sel = 3'b000;
    assign tx_cfg_gnt = 1'b1;

    // Interrupt tie-offs when using MSI-X only
    assign cfg_interrupt = 1'b0;
    assign cfg_interrupt_assert = 1'b0;
    assign cfg_interrupt_di = 8'h00;
    assign cfg_interrupt_stat = 1'b0;
    assign cfg_pciecap_interrupt_msgnum = 5'h00;

{%- if _expose_pm_sideband %}
    // Default safe values for optional PM sideband when not wired internally
{%- if _enable_pme %}
    // If no internal PM block drives To_Ack, hold low; allow external connection
    assign pme_to_ack = 1'b0;
    // If AUX not driven externally, expect board logic to tie appropriately
    // (no internal assignment for inputs pme_turnoff/aux_pwr_present)
{%- endif %}
{%- if _enable_wake_events %}
    // Deassert WAKE# by default (active-low)
    assign wake_n = 1'b1;
{%- endif %}
{%- endif %}

    // Simplified BAR memory (for basic protocol compliance)
    // Note: Full BAR controller with cfg_ext_* requires UltraScale+ or external logic
    logic [31:0] bar_memory [0:1023];  // 4KB simple memory
    
    // Initialize BAR memory to known pattern
    initial begin
        for (int i = 0; i < 1024; i++) begin
            bar_memory[i] = 32'hDEADBEEF;
        end
    end
    
    // Simple BAR read/write logic (placeholder for full implementation)
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            bar_rd_data <= 32'h0;
        end else begin
            if (bar_rd_en && bar_addr[31:12] == 20'h0) begin
                bar_rd_data <= bar_memory[bar_addr[11:2]];
            end
            if (bar_wr_en && bar_addr[31:12] == 20'h0) begin
                bar_memory[bar_addr[11:2]] <= bar_wr_data;
            end
        end
    end

    // Debug status signal (already declared above)

    // Basic PCIe TLP processing for protocol compliance
    typedef enum logic [1:0] {
        TLP_IDLE,
        TLP_HEADER,
        TLP_PROCESSING
    } tlp_state_t;

    tlp_state_t tlp_state;
    logic [31:0] tlp_header [0:3];
    logic [7:0]  tlp_header_count;
    logic [10:0] tlp_length;
    logic [6:0]  tlp_type;
    logic [31:0] tlp_address;

    // Simplified PCIe TLP processing for basic protocol compliance
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            pcie_tx_data <= '0;
            pcie_tx_valid <= 1'b0;
            debug_status <= 32'h0;
            tlp_state <= TLP_IDLE;
            tlp_header_count <= 8'h0;
            bar_addr <= 32'h0;
            bar_wr_data <= 32'h0;
            bar_wr_en <= 1'b0;
            bar_rd_en <= 1'b0;
        end else begin
            // Default assignments
            pcie_tx_valid <= 1'b0;

            case (tlp_state)
                TLP_IDLE: begin
                    if (pcie_rx_valid) begin
                        {%- if _data_width == 64 %}
                        tlp_header[0] <= pcie_rx_data[31:0];
                        {%- else %}
                        tlp_header[0] <= pcie_rx_data;
                        {%- endif %}
                        tlp_header_count <= 8'h1;
                        tlp_state <= TLP_HEADER;

                        // Extract TLP type and length from first header
                        {%- if _data_width == 64 %}
                        tlp_type <= pcie_rx_data[30:24];
                        tlp_length <= pcie_rx_data[9:0];
                        {%- else %}
                        tlp_type <= pcie_rx_data[30:24];
                        tlp_length <= pcie_rx_data[9:0];
                        {%- endif %}
                    end
                end

                TLP_HEADER: begin
                    if (pcie_rx_valid) begin
                        {%- if _data_width == 64 %}
                        tlp_header[tlp_header_count] <= pcie_rx_data[31:0];
                        {%- else %}
                        tlp_header[tlp_header_count] <= pcie_rx_data;
                        {%- endif %}
                        tlp_header_count <= tlp_header_count + 1;

                        // For memory requests, capture address from header[1]
                        if (tlp_header_count == 8'h1) begin
                            {%- if _data_width == 64 %}
                            tlp_address <= pcie_rx_data[31:0];
                            bar_addr <= pcie_rx_data[31:0];
                            {%- else %}
                            tlp_address <= pcie_rx_data;
                            bar_addr <= pcie_rx_data;
                            {%- endif %}
                        end

                        // Basic TLP acknowledgment
                        if (tlp_header_count >= 8'h2) begin
                            tlp_state <= TLP_PROCESSING;
                            // Trigger BAR read for memory read requests
                            if (tlp_type[6:5] == 2'b00) begin  // Memory read
                                bar_rd_en <= 1'b1;
                            end
                        end
                    end
                end

                TLP_PROCESSING: begin
                    // Clear BAR enables
                    bar_rd_en <= 1'b0;
                    bar_wr_en <= 1'b0;
                    
                    // Send response if it was a read
                    if (tlp_type[6:5] == 2'b00) begin  // Memory read
                        {%- if _data_width == 64 %}
                        pcie_tx_data <= {bar_rd_data, 32'h0};
                        {%- else %}
                        pcie_tx_data <= bar_rd_data;
                        {%- endif %}
                        pcie_tx_valid <= 1'b1;
                    end
                    
                    tlp_state <= TLP_IDLE;
                end

                default: begin
                    // Default case to ensure all LUT inputs are connected
                    tlp_state <= TLP_IDLE;
                end
            endcase

            // Update debug status with device ID and current state
            {% set _vendor_str = get_vendor_id(active_device_config, device, config_space, vendor_id_int) %}
            {% set _device_str = get_device_id(active_device_config, device, config_space, device_id_int) %}
            debug_status <= {16'h{{ _vendor_str }}, 8'h{{ _device_str[:2] }}, 5'h0, tlp_state};
        end
    end

{%- if board is defined and board.has_status_leds | default(false) %}
    // LED status output - show device ready and current state
    assign led_status = { {%- if board.num_status_leds | default(8) > 3 -%}{{ board.num_status_leds | default(8) - 3 }}'h0, {% endif %}device_ready, tlp_state};
{%- endif %}

endmodule

`default_nettype wire